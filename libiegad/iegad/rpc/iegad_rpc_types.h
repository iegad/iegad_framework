/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef iegad_rpc_TYPES_H
#define iegad_rpc_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace iegad { namespace rpc {

typedef class request response;

class request;

typedef struct _request__isset {
  _request__isset() : msg_type(true), msg_flag(true), msg_time(true), msg_data(false) {}
  bool msg_type :1;
  bool msg_flag :1;
  bool msg_time :1;
  bool msg_data :1;
} _request__isset;

class request {
 public:

  request(const request&);
  request& operator=(const request&);
  request() : msg_type(-1), msg_flag(0), msg_time(0LL), msg_data() {
  }

  virtual ~request() throw();
  int32_t msg_type;
  int32_t msg_flag;
  int64_t msg_time;
  std::string msg_data;

  _request__isset __isset;

  void __set_msg_type(const int32_t val);

  void __set_msg_flag(const int32_t val);

  void __set_msg_time(const int64_t val);

  void __set_msg_data(const std::string& val);

  bool operator == (const request & rhs) const
  {
    if (__isset.msg_type != rhs.__isset.msg_type)
      return false;
    else if (__isset.msg_type && !(msg_type == rhs.msg_type))
      return false;
    if (__isset.msg_flag != rhs.__isset.msg_flag)
      return false;
    else if (__isset.msg_flag && !(msg_flag == rhs.msg_flag))
      return false;
    if (__isset.msg_time != rhs.__isset.msg_time)
      return false;
    else if (__isset.msg_time && !(msg_time == rhs.msg_time))
      return false;
    if (__isset.msg_data != rhs.__isset.msg_data)
      return false;
    else if (__isset.msg_data && !(msg_data == rhs.msg_data))
      return false;
    return true;
  }
  bool operator != (const request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(request &a, request &b);

inline std::ostream& operator<<(std::ostream& out, const request& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
