/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef rdmServer_H
#define rdmServer_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "redis_rdm_types.h"

namespace rdm {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class rdmServerIf {
 public:
  virtual ~rdmServerIf() {}
  virtual void GetKeys(std::vector<RedisData_t> & _return, const std::string& qurey_str) = 0;
  virtual void GetValue(RedisData_t& _return, const std::string& _key__, const std::string& _type__) = 0;
  virtual bool Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password) = 0;
  virtual bool Select(const int16_t db_index) = 0;
};

class rdmServerIfFactory {
 public:
  typedef rdmServerIf Handler;

  virtual ~rdmServerIfFactory() {}

  virtual rdmServerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(rdmServerIf* /* handler */) = 0;
};

class rdmServerIfSingletonFactory : virtual public rdmServerIfFactory {
 public:
  rdmServerIfSingletonFactory(const boost::shared_ptr<rdmServerIf>& iface) : iface_(iface) {}
  virtual ~rdmServerIfSingletonFactory() {}

  virtual rdmServerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(rdmServerIf* /* handler */) {}

 protected:
  boost::shared_ptr<rdmServerIf> iface_;
};

class rdmServerNull : virtual public rdmServerIf {
 public:
  virtual ~rdmServerNull() {}
  void GetKeys(std::vector<RedisData_t> & /* _return */, const std::string& /* qurey_str */) {
    return;
  }
  void GetValue(RedisData_t& /* _return */, const std::string& /* _key__ */, const std::string& /* _type__ */) {
    return;
  }
  bool Connect(const std::string& /* ipstr */, const int32_t /* port */, const std::string& /* usrid */, const std::string& /* password */) {
    bool _return = false;
    return _return;
  }
  bool Select(const int16_t /* db_index */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _rdmServer_GetKeys_args__isset {
  _rdmServer_GetKeys_args__isset() : qurey_str(false) {}
  bool qurey_str :1;
} _rdmServer_GetKeys_args__isset;

class rdmServer_GetKeys_args {
 public:

  rdmServer_GetKeys_args(const rdmServer_GetKeys_args&);
  rdmServer_GetKeys_args& operator=(const rdmServer_GetKeys_args&);
  rdmServer_GetKeys_args() : qurey_str() {
  }

  virtual ~rdmServer_GetKeys_args() throw();
  std::string qurey_str;

  _rdmServer_GetKeys_args__isset __isset;

  void __set_qurey_str(const std::string& val);

  bool operator == (const rdmServer_GetKeys_args & rhs) const
  {
    if (!(qurey_str == rhs.qurey_str))
      return false;
    return true;
  }
  bool operator != (const rdmServer_GetKeys_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_GetKeys_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class rdmServer_GetKeys_pargs {
 public:


  virtual ~rdmServer_GetKeys_pargs() throw();
  const std::string* qurey_str;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_GetKeys_result__isset {
  _rdmServer_GetKeys_result__isset() : success(false) {}
  bool success :1;
} _rdmServer_GetKeys_result__isset;

class rdmServer_GetKeys_result {
 public:

  rdmServer_GetKeys_result(const rdmServer_GetKeys_result&);
  rdmServer_GetKeys_result& operator=(const rdmServer_GetKeys_result&);
  rdmServer_GetKeys_result() {
  }

  virtual ~rdmServer_GetKeys_result() throw();
  std::vector<RedisData_t>  success;

  _rdmServer_GetKeys_result__isset __isset;

  void __set_success(const std::vector<RedisData_t> & val);

  bool operator == (const rdmServer_GetKeys_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const rdmServer_GetKeys_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_GetKeys_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_GetKeys_presult__isset {
  _rdmServer_GetKeys_presult__isset() : success(false) {}
  bool success :1;
} _rdmServer_GetKeys_presult__isset;

class rdmServer_GetKeys_presult {
 public:


  virtual ~rdmServer_GetKeys_presult() throw();
  std::vector<RedisData_t> * success;

  _rdmServer_GetKeys_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _rdmServer_GetValue_args__isset {
  _rdmServer_GetValue_args__isset() : _key__(false), _type__(false) {}
  bool _key__ :1;
  bool _type__ :1;
} _rdmServer_GetValue_args__isset;

class rdmServer_GetValue_args {
 public:

  rdmServer_GetValue_args(const rdmServer_GetValue_args&);
  rdmServer_GetValue_args& operator=(const rdmServer_GetValue_args&);
  rdmServer_GetValue_args() : _key__(), _type__() {
  }

  virtual ~rdmServer_GetValue_args() throw();
  std::string _key__;
  std::string _type__;

  _rdmServer_GetValue_args__isset __isset;

  void __set__key__(const std::string& val);

  void __set__type__(const std::string& val);

  bool operator == (const rdmServer_GetValue_args & rhs) const
  {
    if (!(_key__ == rhs._key__))
      return false;
    if (!(_type__ == rhs._type__))
      return false;
    return true;
  }
  bool operator != (const rdmServer_GetValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_GetValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class rdmServer_GetValue_pargs {
 public:


  virtual ~rdmServer_GetValue_pargs() throw();
  const std::string* _key__;
  const std::string* _type__;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_GetValue_result__isset {
  _rdmServer_GetValue_result__isset() : success(false) {}
  bool success :1;
} _rdmServer_GetValue_result__isset;

class rdmServer_GetValue_result {
 public:

  rdmServer_GetValue_result(const rdmServer_GetValue_result&);
  rdmServer_GetValue_result& operator=(const rdmServer_GetValue_result&);
  rdmServer_GetValue_result() {
  }

  virtual ~rdmServer_GetValue_result() throw();
  RedisData_t success;

  _rdmServer_GetValue_result__isset __isset;

  void __set_success(const RedisData_t& val);

  bool operator == (const rdmServer_GetValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const rdmServer_GetValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_GetValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_GetValue_presult__isset {
  _rdmServer_GetValue_presult__isset() : success(false) {}
  bool success :1;
} _rdmServer_GetValue_presult__isset;

class rdmServer_GetValue_presult {
 public:


  virtual ~rdmServer_GetValue_presult() throw();
  RedisData_t* success;

  _rdmServer_GetValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _rdmServer_Connect_args__isset {
  _rdmServer_Connect_args__isset() : ipstr(false), port(false), usrid(false), password(false) {}
  bool ipstr :1;
  bool port :1;
  bool usrid :1;
  bool password :1;
} _rdmServer_Connect_args__isset;

class rdmServer_Connect_args {
 public:

  rdmServer_Connect_args(const rdmServer_Connect_args&);
  rdmServer_Connect_args& operator=(const rdmServer_Connect_args&);
  rdmServer_Connect_args() : ipstr(), port(0), usrid(), password() {
  }

  virtual ~rdmServer_Connect_args() throw();
  std::string ipstr;
  int32_t port;
  std::string usrid;
  std::string password;

  _rdmServer_Connect_args__isset __isset;

  void __set_ipstr(const std::string& val);

  void __set_port(const int32_t val);

  void __set_usrid(const std::string& val);

  void __set_password(const std::string& val);

  bool operator == (const rdmServer_Connect_args & rhs) const
  {
    if (!(ipstr == rhs.ipstr))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(usrid == rhs.usrid))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const rdmServer_Connect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_Connect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class rdmServer_Connect_pargs {
 public:


  virtual ~rdmServer_Connect_pargs() throw();
  const std::string* ipstr;
  const int32_t* port;
  const std::string* usrid;
  const std::string* password;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_Connect_result__isset {
  _rdmServer_Connect_result__isset() : success(false) {}
  bool success :1;
} _rdmServer_Connect_result__isset;

class rdmServer_Connect_result {
 public:

  rdmServer_Connect_result(const rdmServer_Connect_result&);
  rdmServer_Connect_result& operator=(const rdmServer_Connect_result&);
  rdmServer_Connect_result() : success(0) {
  }

  virtual ~rdmServer_Connect_result() throw();
  bool success;

  _rdmServer_Connect_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const rdmServer_Connect_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const rdmServer_Connect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_Connect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_Connect_presult__isset {
  _rdmServer_Connect_presult__isset() : success(false) {}
  bool success :1;
} _rdmServer_Connect_presult__isset;

class rdmServer_Connect_presult {
 public:


  virtual ~rdmServer_Connect_presult() throw();
  bool* success;

  _rdmServer_Connect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _rdmServer_Select_args__isset {
  _rdmServer_Select_args__isset() : db_index(false) {}
  bool db_index :1;
} _rdmServer_Select_args__isset;

class rdmServer_Select_args {
 public:

  rdmServer_Select_args(const rdmServer_Select_args&);
  rdmServer_Select_args& operator=(const rdmServer_Select_args&);
  rdmServer_Select_args() : db_index(0) {
  }

  virtual ~rdmServer_Select_args() throw();
  int16_t db_index;

  _rdmServer_Select_args__isset __isset;

  void __set_db_index(const int16_t val);

  bool operator == (const rdmServer_Select_args & rhs) const
  {
    if (!(db_index == rhs.db_index))
      return false;
    return true;
  }
  bool operator != (const rdmServer_Select_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_Select_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class rdmServer_Select_pargs {
 public:


  virtual ~rdmServer_Select_pargs() throw();
  const int16_t* db_index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_Select_result__isset {
  _rdmServer_Select_result__isset() : success(false) {}
  bool success :1;
} _rdmServer_Select_result__isset;

class rdmServer_Select_result {
 public:

  rdmServer_Select_result(const rdmServer_Select_result&);
  rdmServer_Select_result& operator=(const rdmServer_Select_result&);
  rdmServer_Select_result() : success(0) {
  }

  virtual ~rdmServer_Select_result() throw();
  bool success;

  _rdmServer_Select_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const rdmServer_Select_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const rdmServer_Select_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rdmServer_Select_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _rdmServer_Select_presult__isset {
  _rdmServer_Select_presult__isset() : success(false) {}
  bool success :1;
} _rdmServer_Select_presult__isset;

class rdmServer_Select_presult {
 public:


  virtual ~rdmServer_Select_presult() throw();
  bool* success;

  _rdmServer_Select_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class rdmServerClient : virtual public rdmServerIf {
 public:
  rdmServerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  rdmServerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void GetKeys(std::vector<RedisData_t> & _return, const std::string& qurey_str);
  void send_GetKeys(const std::string& qurey_str);
  void recv_GetKeys(std::vector<RedisData_t> & _return);
  void GetValue(RedisData_t& _return, const std::string& _key__, const std::string& _type__);
  void send_GetValue(const std::string& _key__, const std::string& _type__);
  void recv_GetValue(RedisData_t& _return);
  bool Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password);
  void send_Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password);
  bool recv_Connect();
  bool Select(const int16_t db_index);
  void send_Select(const int16_t db_index);
  bool recv_Select();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class rdmServerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<rdmServerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (rdmServerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_GetKeys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Select(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  rdmServerProcessor(boost::shared_ptr<rdmServerIf> iface) :
    iface_(iface) {
    processMap_["GetKeys"] = &rdmServerProcessor::process_GetKeys;
    processMap_["GetValue"] = &rdmServerProcessor::process_GetValue;
    processMap_["Connect"] = &rdmServerProcessor::process_Connect;
    processMap_["Select"] = &rdmServerProcessor::process_Select;
  }

  virtual ~rdmServerProcessor() {}
};

class rdmServerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  rdmServerProcessorFactory(const ::boost::shared_ptr< rdmServerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< rdmServerIfFactory > handlerFactory_;
};

class rdmServerMultiface : virtual public rdmServerIf {
 public:
  rdmServerMultiface(std::vector<boost::shared_ptr<rdmServerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~rdmServerMultiface() {}
 protected:
  std::vector<boost::shared_ptr<rdmServerIf> > ifaces_;
  rdmServerMultiface() {}
  void add(boost::shared_ptr<rdmServerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void GetKeys(std::vector<RedisData_t> & _return, const std::string& qurey_str) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetKeys(_return, qurey_str);
    }
    ifaces_[i]->GetKeys(_return, qurey_str);
    return;
  }

  void GetValue(RedisData_t& _return, const std::string& _key__, const std::string& _type__) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetValue(_return, _key__, _type__);
    }
    ifaces_[i]->GetValue(_return, _key__, _type__);
    return;
  }

  bool Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Connect(ipstr, port, usrid, password);
    }
    return ifaces_[i]->Connect(ipstr, port, usrid, password);
  }

  bool Select(const int16_t db_index) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Select(db_index);
    }
    return ifaces_[i]->Select(db_index);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class rdmServerConcurrentClient : virtual public rdmServerIf {
 public:
  rdmServerConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  rdmServerConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void GetKeys(std::vector<RedisData_t> & _return, const std::string& qurey_str);
  int32_t send_GetKeys(const std::string& qurey_str);
  void recv_GetKeys(std::vector<RedisData_t> & _return, const int32_t seqid);
  void GetValue(RedisData_t& _return, const std::string& _key__, const std::string& _type__);
  int32_t send_GetValue(const std::string& _key__, const std::string& _type__);
  void recv_GetValue(RedisData_t& _return, const int32_t seqid);
  bool Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password);
  int32_t send_Connect(const std::string& ipstr, const int32_t port, const std::string& usrid, const std::string& password);
  bool recv_Connect(const int32_t seqid);
  bool Select(const int16_t db_index);
  int32_t send_Select(const int16_t db_index);
  bool recv_Select(const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

} // namespace

#endif
